= x86 Bare Metal Examples
:idprefix:
:idseparator: -
:sectanchors:
:sectlinks:
:sectnumlevels: 6
:sectnums:
:toc: macro
:toclevels: 6
:toc-title:

Dozens of minimal operating systems to learn x86 system programming. Tested on Ubuntu 17.10 host. Userland cheat at: https://github.com/cirosantilli/x86-assembly-cheat

toc::[]

== Getting started

First read this introduction: https://stackoverflow.com/questions/22054578/how-to-run-a-program-without-an-operating-system/32483545#32483545

On Ubuntu:

....
./configure
make
....

Each `.S` file on the top-level is an operating system! It gets compiled to a corresponding `.img` file.

Run the default OS on QEMU:

....
make run
....

Run a given OS:

....
make run RUN=min
make run RUN=bios_one_char
....

Use Bochs instead of QEMU:

....
make bochs RUN=min
....

=== Getting started with real hardware

Insert an USB, determine its device (`/dev/sdX`) with:

....
sudo lsblk
sudo fdisk -l
....

Pick the `.img` file that you wan to run and:

....
sudo dd if=bios_hello_world.img of=/dev/sdX
....

Then:

* insert the USB in a computer
* during boot, hit some special hardware dependant key, usually F12, Esc
* choose to boot from the USB

When you are done, just hit the power button to shutdown.

Tested on: ThinkPad T400.

==== Getting started with the big image

Create a `big.img` that contains all examples that can be booted from GRUB:

....
make big.img
....

Now if you do:

....
sudo dd if=big.img of=/dev/sdX
....

you can test several examples with a single USB burn, which is much faster.

You can also try out the big image on QEMU for fun with:

....
qemu-system-i386 -hda big.img
....

You will also want to change the boot order to put the USB first from the F12 BIOS menu. This way you don't have to hit F12 like a madman every time.

TODO: boot sectors that load STAGE2 are not working with the big image chainloader. TODO why?

=== Getting started with Docker

If you don't have an Ubuntu box, this is an easy alternative:

....
sudo docker run -it --net=host ubuntu:14.04 bash
....

Then proceed normally in the guest: install packages, and build:

....
apt-get update
apt-get install git
git clone https://github.com/cirosantilli/x86-bare-metal-examples
cd x86-bare-metal-examples
./configure
make
....

To overcome the lack of GUI, we can use QEMU's VNC implementation instead of the default SDL, which is visible on the host due to `--net=host`:

....
qemu-system-i386 -hda main.img -vnc :0
....

and then on host:

....
sudo apt-get install vinagre
vinagre localhost:5900
....

=== GDB step debug

TODO get it working nicely.

This will only cover specifics, you have to know GDB debugging already.

How to have debug symbols: https://stackoverflow.com/questions/32955887/how-to-disassemble-16-bit-x86-boot-sector-code-in-gdb-with-x-i-pc-it-gets-tr/32960272#32960272 TODO implement here. Needs to point GDB to an ELF file in addition to the remote listen.

How to step over `int` calls: http://stackoverflow.com/questions/24491516/how-to-step-over-interrupt-calls-when-debugging-a-bootloader-bios-with-gdb-and-q

Single stepping until a given opcode can be helpful sometimes: https://stackoverflow.com/questions/14031930/break-on-instruction-with-specific-opcode-in-gdb/31249378#31249378

TODO: detect if we are on 16 or 32 bit automatically from control registers. Now I'm using 2 functions `16` and `32` to switch manually, but that sucks. The problem is that it's not possible to read them directly: http://stackoverflow.com/a/31340294/895245 If we had `cr0`, it would be easy to do with an `if cr0 & 1` inside a hook-stop.

TODO: Take segmentation offsets into account: http://stackoverflow.com/questions/10354063/how-to-use-a-logical-address-in-gdb

== Minimal examples

These are the first ones you should look at.

[[printf]]
=== Create a minimal image with printf

....
cd printf/
make run
....

Outcome: QEMU window opens up, prints a few boot messages, and hangs.

Minimal boot sector example that does nothing, just halts immediately.

Generated with `printf` byte by byte.

You can't get more minimal than this.

=== Minimal GAS example

link:min.S[]

=== BIOS hello world

link:bios_hello_world.S[]

=== No linker script

....
cd no-linker-lscript
make run
....

Outcome:

....
hello world
....

Uses the default host `ld` script, not an explicit one set with `-T`. Uses:

* `-tText`
* `.org` inside each assembly file
* `_start` must be present to avoid a warning, since the default linker script expects it

Less stable, but more convenient for quick and dirty tests.

== BIOS

https://en.wikipedia.org/wiki/BIOS

http://wiki.osdev.org/BIOS

The BIOS is one of the most well known firmwares in existence.

A firmware is a software a software that:

* runs before the OS / bootloader to do very low level setup
* usually closed source, provided by the vendor, and interacts with undocumented hardware APIs
* offers an API to the OS / bootloader, that allows you to do things like quick and dirty IO
* undistinguishable from an OS, except that is it usually smaller

BIOS is old, non-standardized, x86 omnipresent and limited.

<<uefi>> is the shiny new overbloated thing.

If you are making a serious OS, use it as little as possible.

Can only be used in real mode.

=== BIOS documentation

Does any documentation or portability exist?

* http://www.ctyme.com/intr/int.htm Ralf Brown's Interrupt List. Everyone says that this is the ultimate unofficial compilation.
* https://en.wikipedia.org/wiki/INT_10H good quick summary
* http://www.scs.stanford.edu/nyu/04fa/lab/specsbbs101.pdf says little about interrupts, I don't understand it's scope.

=== BIOS examples

. link:bios_putc.S[]
. link:bios_newline.S[]
. link:bios_carriage_return.S[]
. link:bios_cursor_position.S[]
. link:bios_color.S[]
. link:bios_background.S[]
. link:bios_scroll.S[]
.. link:bios_clear_screen.S[]
. link:bios_pixel.S[]
.. link:bios_pixel_line.S[]
. link:bios_keyboard.S[]
.. link:bios_keyboard_loop.S[]
. link:bios_disk_load.S[]
.. link:bios_disk_load2.S[]
. link:bios_detect_memory.S[]
. link:bios_tick_count.S[]
. link:bios_initial_state.S[]

=== Get BIOS information

* http://stackoverflow.com/questions/20604644/how-to-check-the-bios-version-or-name-in-linux-through-command-prompt
* https://en.wikipedia.org/wiki/System_Management_BIOS SMBIOS

On host:

....
sudo dmidecode
....

Standardized by: https://en.wikipedia.org/wiki/Distributed_Management_Task_Force

TODO: how is it obtained at the low level?

=== SeaBIOS

http://www.seabios.org/SeaBIOS

Open source x86 BIOS implementation.

Default BIOS for QEMU and KVM.

== UEFI

https://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface

Successor for <<bios>>.

Made by Intel, mostly MIT open source, which likely implies that vendors will hack away closed source versions.

link:https://mjg59.dreamwidth.org/10014.html[Matthew Garrett says] it is huge: larger than Linux without drivers.

Since it is huge, it inevitably contains bugs. Garret says that Intel sometimes does not feel like updating the firmware with bugfixes.

UEFI offers a large API comparable to what most people would call an operating system:

* https://software.intel.com/en-us/articles/uefi-application mentions a POSIX C library port
* https://lwn.net/Articles/641244/ mentions a Python interpreter port!

ARM is considering an implementation https://wiki.linaro.org/ARM/UEFI

=== UEFI example

link:uefi/[]

....
cd uefi
make run
....

TODO get a hello world program working:

* http://www.rodsbooks.com/efi-programming/hello.html Best source so far: allowed me to compile the hello world! TODO: how to run it now on QEMU and real hardware?
* https://fedoraproject.org/wiki/Using_UEFI_with_QEMU
* https://wiki.ubuntu.com/UEFI/OVMF
* https://github.com/tqh/efi-example

Running without image gives the UEFI shell, and a Linux kernel image booted fine with it: http://unix.stackexchange.com/a/228053/32558 , so we just need to generate the image.

`ovmf.fd` IA32 r15214 was downloaded from: https://sourceforge.net/projects/edk2/files/OVMF/OVMF-IA32-r15214.zip/download Included in-source for convenience, even though it is ugly.

=== UEFI Bibliography

* https://www.youtube.com/watch?v=V2aq5M3Q76U hardcore kernel dev Matthew Garrett saying how bad UEFI is
* https://wiki.archlinux.org/index.php/Unified_Extensible_Firmware_Interface
* http://wiki.osdev.org/UEFI

== Coreboot

TODO minimal examples.

https://en.wikipedia.org/wiki/Coreboot

https://www.coreboot.org

Open source hippie freedom loving cross platform firmware that attempts to replace BIOS and UEFI for the greater good of mankind.

== GRUB

link:grub/[]

== Multiboot

https://en.wikipedia.org/wiki/Multiboot_Specification

Standard created by GRUB for booting OSes.

Multiboot files are an extension of ELF files with a special header.

Advantages: GRUB does housekeeping magic for you:

* you can store the OS as a regular file inside a filesystem
* your program starts in 32-bit mode already, not 16 bit real mode
* it gets the available memory ranges for you

Disadvantages:

* more boilerplate

GRUB leaves the application into a well defined starting state.

It seems that Linux does not implement Multiboot natively, but GRUB supports it as an exception: http://stackoverflow.com/questions/17909429/booting-a-non-multiboot-kernel-with-grub2

=== Multiboot hello world

QEMU supports multiboot natively https://stackoverflow.com/questions/25469396/how-to-use-qemu-properly-with-multi-boot-headers/32550281#32550281>:

....
cd multiboot/hello-world
make
qemu-system-x86_64 -kernel main.elf
....

where `main.elf` is the multiboot file we generated.

Outcome:

....
hello world
....

Or you can use `grub-mkrescue` to make a multiboot file into a bootable ISO or disk:

....
qemu-system-x86_64 -drive file=main.img,format=raw
....

The `main.img` file can also be burned to a USB and run on real hardware.

Example originally minimized from https://github.com/programble/bare-metal-tetris

.. link:segment_registers.S[Segment registers]
... link:ss.S[SS]
... link:cs.S[CS]

.. link:interrupt.S[Interrupt]
... link:interrupt1.S[int \$1]
... link:interrupt_zero_divide.S[Interrupt zero divide]
... link:interrupt_loop.S[Interrupt loop]

.. link:in.md[in]
... link:in_keyboard.S[in keyboard]
... link:rtc.S[RTC]
... link:pit.S[PIT]
.... link:pit_once.S[PIT once]
... link:in_beep.S[in beep]
... link:in_beep_illinois.S[in beep_illinois]
... link:in_mouse.S[in mouse (TODO)]

. Theory
.. link:formats.md[Formats]
... link:mbr.md[MBR]
.. link:pic.md[PIC]

== Power

=== Shutdown

http://wiki.osdev.org/Shutdown

=== Reboot

link:reboot.S[]

=== APM

* link:apm_shutdown.S[]
* link:apm_shutdown2.S[]

https://en.wikipedia.org/wiki/Advanced_Power_Management

http://wiki.osdev.org/APM

Older than <<acpi>> and simpler.

By Microsoft in 1995. Spec seems to be in RTF format...

Can't find the URL. A Google cache: https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&ved=0CB0QFjAAahUKEwj7qpLN_4XIAhWCVxoKHa_nAxY&url=http%3A%2F%2Fdownload.microsoft.com%2Fdownload%2F1%2F6%2F1%2F161ba512-40e2-4cc9-843a-923143f3456c%2FAPMV12.rtf&usg=AFQjCNHoCx8gHv-w08Dn_Aoy6Q3K3DLWRg&sig2=D_66xvI7Y2n1cvyB8d2Mmg

=== ACPI

TODO example

ACPI https://en.wikipedia.org/wiki/Advanced_Configuration_and_Power_Interface

Newer and better.

Now managed by the same group that manages UEFI.

Spec:

* current: http://uefi.org/specifications
* old: http://www.uefi.org/acpi/specs

== Modes of operation

The x86 processor has a few modes, which have huge impact on how the processor works.

Covered on Intel Volume 3. Specially useful is the "Transitions Among the Processor's Operating Modes" diagram.

The modes are:

* Real-address
* Protected
* System management
* IA-32e. Has two sub modes:
** Compatibility
** 64-bit
* Virtual-8086 Mode

Transition tables:

....
(all modes)
|
| Reset
|
v
+---------------------+
| Real address (PE=0) |
+---------------------+
^
|
| PE
|
v
+------------------------+
| Protected (PE=1, VM=0) |
+------------------------+
^                   ^
|                   |
|                   | VM
|                   |
v                   v
+--------------+    +---------------------+
| IA-32e       |    | Virtual-8086 (VM=1) |
+--------------+    +---------------------+
....

and:

....
+------------------------+
| System management mode |
+------------------------+
|          ^
|          |
| RSM      | SMI#
|          |
v          |
(All other modes)
....

The IA-32e transition is trickier, but clearly described on the <<intel-manual>> 9.8.5 Initializing IA-32e Mode:

____
Operating systems should follow this sequence to initialize IA-32e mode:

1. Starting from protected mode, disable paging by setting `CR0.PG = 0`. Use the `MOV CR0` instruction to disable paging (the instruction must be located in an identity-mapped page).
2. Enable physical-address extensions (PAE) by setting CR4.`PAE = 1`. Failure to enable PAE will result in a `#GP` fault when an attempt is made to initialize IA-32e mode.
3. Load `CR3` with the physical base address of the Level 4 page map table (PML4).
4. Enable IA-32e mode by setting `IA32_EFER.LME = 1`.
5. Enable paging by setting `CR0.PG = 1`. This causes the processor to set the `IA32_EFER.LMA` bit to 1. The `MOV CR0` instruction that enables paging and the following instructions must be located in an identity-mapped page (until such time that a branch to non-identity mapped pages can be effected).
____

=== Real mode

http://wiki.osdev.org/Real_Mode

The CPU starts in this mode after power up.

All our <<bios>> examples are in real mode.

It is possible to use 32-bit registers in this mode with the "Operand Size Override Prefix" `0x66`.

TODO is it possible to access memory above 1M like this:

....
mov $1, 0xF0000000
mov $1, (%eax)
....

http://stackoverflow.com/questions/6917503/is-it-possible-to-use-32-bits-registers-instructions-in-real-mode

=== Protected mode

....
make run RUN=protected_mode
....

Major changes from real mode:

* BIOS cannot be used anymore. In particular, we must use VGA functions to get output
* GDT and segmentation take effect immediately so we have to deal with it now
* we have to encode instructions differently, thus a `.code32` is needed. Note that in 16-bit, 32-bit instructions were encodable, but with a prefix.

On the Linux kernel, `arch/x86/include/asm/segment.h` contains a lot of action:

- the user privilege level
- the segment steup (kernel an user code and data segments)

Bibliography:

* http://stackoverflow.com/questions/28645439/how-do-i-enter-32-bit-protected-mode-in-nasm-assembly Initially adapted from this.
* http://wiki.osdev.org/Journey_To_The_Protected_Land
* http://wiki.osdev.org/Protected_Mode
* https://github.com/chrisdew/xv6/blob/master/bootasm.S
* https://thiscouldbebetter.wordpress.com/2011/03/17/entering-protected-mode-from-assembly/ FASM based. Did not word on first try, but looks real clean.
* http://skelix.net/skelixos/tutorial02_en.html

==== Segmentation

TODO: cleanup and get working:

* link:segment_base.S[]
* link:segmentation.adoc[]

==== IDT

... link:idt.S[IDT]
.... link:idt1.S[IDT 1]
.... link:idt_zero_divide.S[IDT zero divide]
.... IDT PIT
... link:pit_protected.S[PIT protected]

==== Protection rings

https://stackoverflow.com/questions/18717016/what-are-ring-0-and-ring-3-in-the-context-of-operating-systems/44483439#44483439

==== SMP

link:smp.S[]

Symmetric multiprocessing https://en.wikipedia.org/wiki/Symmetric_multiprocessing

==== Paging

Verbose beginner's tutorial: http://www.cirosantilli.com/x86-paging/

....
make run RUN=paging
....

Outcome:

....
00001234
00005678
....

Requires <<protected-mode>>.

===== Page fault

link:page_fault.S[]

=== IA-32e mode

Wikipedia seems to call it long mode: https://en.wikipedia.org/wiki/Long_mode

Contains two sub-modes: <<64-bit-mode>> and <<compatibility-mode>>.

This controlled by the `CS.L` bit of the segment descriptor.

It appears that it is possible for user programs to modify that during execution from userland: http://stackoverflow.com/questions/12716419/can-you-enter-x64-32-bit-long-compatibility-sub-mode-outside-of-kernel-mode

=== 64-bit mode

64-bit is the major mode of operation, and enables the full 64 bit instructions.

=== Compatibility mode

Compatibility mode emulates IA-32 and allows to run 32 and 16 bit code.

But 64 bit Linux and Windows don't seem to allow 16 bit code anymore?

* http://stackoverflow.com/questions/27868394/switch-from-64-bit-long-mode-to-32-bit-compatibility-mode-on-x64
* https://stackoverflow.com/questions/7829058/how-to-run-16-bit-code-on-32-bit-linux
* https://superuser.com/questions/140953/why-cant-a-64-bit-os-run-a-16-bit-application

Compatibility vs protected: https://stackoverflow.com/questions/20848412/modes-of-intel-64-cpu

== Video mode

There are several video modes.

Modes determine what interrupt functions can be used.

There are 2 main types of modes:

* text, where we operate character-wise
* video, operate byte-wise

Modes can be set with `int 0x10` and `AH = 0x00`, and get with `AH = 0x0F`

The most common modes seem to be:

* 0x01: 40x25 Text, 16 colors, 8 pages
* 0x03: 80x25 Text, 16 colors, 8 pages
* 0x13: 320x200 Graphics, 256 colors, 1 page

You can add 128 to the modes to prevent them from clearing the screen.

Taken from: https://courses.engr.illinois.edu/ece390/books/labmanual/graphics-int10h.html

A larger list: http://www.columbia.edu/~em36/wpdos/videomodes.txt

=== VGA

* https://en.wikipedia.org/wiki/Video_Graphics_Array
* https://en.wikipedia.org/wiki/VGA-compatible_text_mode

TODO: what is it exactly?

BIOS cannot be used when we move into protected mode, but we can use the VGA interface to get output out of our programs.

Have a look at the macros prefixed with `VGA_` inside link:common.h[].

=== VBE

https://en.wikipedia.org/wiki/VESA_BIOS_Extensions

TODO use it.

== Unit tests

Tests for utilities defined in this repo, as opposed to x86 or external firmware concepts.

* link:test_print_bytes.S[PRINT_BYTES]
* link:test_pit_sleep.S[PIT_SLEEP]

== About

=== System vs userland

This repository covers only things that can only be done from ring 0 (system) and not ring 3 (userland).

Ring 3 is covered at: https://github.com/cirosantilli/x86-assembly-cheat

An overview of rings 0 and 3 can be found at: https://stackoverflow.com/questions/18717016/what-are-ring-0-and-ring-3-in-the-context-of-operating-systems/44483439#44483439

=== One minimal concept per OS

There are a few tutorials that explain how to make an operating system and give examples of increasing complexity with more and more functionality added.

This is not one of them.

The goal of this repository is to use the minimal setup possible to be able to observe _a single_ low-level programming concept for each minimal operating system we create.

This is not meant provide a template from which you can write a real OS, but instead to illustrate how those low-level concepts work in isolation, so that you can use that knowledge to implement operating systems or drivers.

Minimal examples are useful because it is easier to observe the requirements for a given concept to be observable.

Another advantage is that it is easier to DRY up minimal examples (here done simply through `#include` and macros), which is much harder on progressive OS template tutorials, which tend to repeat big chunks of code between the examples.

=== To C or not to C

Using C or not is a hard choice.

It does make it much easier to express higher level ideas, and gives portability.

But in the end, it increases the complexity that one has to understand, so we've stayed away from it.

=== NASM

....
cd nasm/
make
make run RUN=bios_hello_world
....

While NASM is a bit more convenient than GAS to write a boot sector, I think it is just not worth it.

When writing an OS in C, we are going to use GCC, which already uses GAS. So it's better to reduce the number of assemblers to one and stick to GAS only.

Right now, this directory is not very DRY since NASM is secondary to me, so it contains mostly some copy / paste examples.

On top of that, GAS also supports other architectures besides x86, so learning it is more useful in that sense.

=== Linux is open source

Always try looking into the Linux kernel to find how those CPU capabilities are used in a "real" OS.

=== Pre-requisites

OS dev is one of the most insanely hard programming tasks a person can undertake, and will push your knowledge of several domains to the limit.

Knowing the following will help a lot:

* userland x86 assembly: https://github.com/cirosantilli/assembly-cheat
* compilation, linking and ELF format basics
* GDB debugging

While it is possible to learn those topics as you go along, and it is almost certain that you will end up learning more about them, we will not explain them here in detail.

== Bibliography

=== Intel manual

We are interested mostly in the "Intel Manual Volume 3 System Programming Guide", where system programming basically means "OS stuff" or "bare metal" as opposed to userland present in the other manuals.

This repository quotes by default the following revision: 325384-056US September 2015 https://web.archive.org/web/20151025081259/http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-system-programming-manual-325384.pdf

=== Small educational projects

Fun, educational and useless:

* https://github.com/programble/bare-metal-tetris tested on Ubuntu 14.04. Just works.
+
Has Multiboot and El Torito. Uses custom linker script.
+
Almost entirely in C `-nostdlib`, with very few inline `asm` commands, and a small assembly entry point. So a good tutorial in how to do the bridge.
* https://github.com/daniel-e/tetros Tetris that fits into bootloader.
* https://github.com/arjun024/mkeykernel, https://github.com/arjun024/mkernel
+
Worked, but bad build system: not `Makefile` or `.gitignore`.
* https://github.com/Overv/MineAssemble

The following did not work on my machine out of the box:

* https://github.com/apparentlymart/ToyOS
* https://github.com/rde1024/toyos

=== Tutorials

* https://farid.hajji.org/en/blog/46-hello-world-on-the-bare-metal
* https://arobenko.gitbooks.io/bare_metal_cpp/content/

==== Educational NIXes

One complexity order above the minimal tutorials, one below actual kernels

* http://www.xinu.cs.purdue.edu/
* https://pdos.csail.mit.edu/6.828/2014/xv6.html
* https://en.wikipedia.org/wiki/MINIX, influenced Linux

==== Educational non-NIXes

* https://github.com/intermezzOS/book
* https://github.com/flosse/rust-os-comparison

=== Multi collaborator websites

* osdev.org is a major source for this.
** http://wiki.osdev.org/C%2B%2B_Bare_Bones
** http://wiki.osdev.org/Text_UI
** http://wiki.osdev.org/GUI
* http://www.osdever.net/
* https://courses.engr.illinois.edu/ece390/books/labmanual/index.html Illinois course from 2004

=== Progressive tutorials

* http://www.jamesmolloy.co.uk/tutorial_html/index.html
+
Highly recommended.
+
Multiboot based kernels of increasing complexity, one example builds on the last one. Non DRY as a result.
+
Cleaned up source code: https://github.com/cirosantilli/jamesmolloy-kernel-development-tutorials
+
Well known bugs: http://wiki.osdev.org/James_Molloy's_Tutorial_Known_Bugs That's what happens when you don't use GitHub.
+
Good tutorials, author seems to master the subject.
+
But he could learn more about version control and build automation: source code inside ugly tar.gz with output files.
* https://sourceforge.net/p/oszur11/code/ci/master/tree/
+
GitHub mirror: https://github.com/cirosantilli/oszur11-operating-system-examples
+
Several examples of increasing complexity. Found at: http://stackoverflow.com/questions/7130726/writing-a-hello-world-kernel
+
Just works, but examples are non-minimal, lots of code duplication and blobs. There must be around 20 El Torito blobs in that repo.
+
Multiboot based.
* https://github.com/SamyPesse/How-to-Make-a-Computer-Operating-System
* http://www.brokenthorn.com/Resources/OSDevIndex.html
* http://skelix.net/skelixos/index_en.html
+
Cleaned up version: https://github.com/cirosantilli/skelix-os
+
Not tested yet.
+
GAS based, no multiboot used.
* https://github.com/littleosbook/littleosbook

=== Actually useful

These are not meant as learning resources but rather as useful programs:

* https://github.com/scanlime/metalkit A more automated / general bare metal compilation system. Untested, but looks promising.
* Python without an "OS": https://us.pycon.org/2015/schedule/presentation/378/

=== Other archs

For when we decide to port this tutorial:

ARM:

* https://github.com/bravegnu/gnu-eprog

Raspberry PI:

* https://github.com/dwelch67/raspberrypi
* https://github.com/BrianSidebotham/arm-tutorial-rpi

== TODO

Stuff here is too messy to put on the main README, need either cleanup or a working example:

* link:TODO.adoc[]
* link:intel-startup/[]

== LICENSE

Copyright Ciro Santilli http://www.cirosantilli.com/

https://www.gnu.org/licenses/gpl-3.0.txt[GPL v3] for executable computer program usage.

https://creativecommons.org/licenses/by-sa/4.0/[CC BY-SA v4] for human consumption usage in learning material, e.g. `.md` files, source code comments, using source code excerpts in tutorials. Recommended attribution:

* Single file adaptations:
+
....
Based on https://github.com/cirosantilli/x86-bare-metal-examples/blob/<commit-id>/path/to/file.md under CC BY-SA v4
....
* Multi-file adaptations:
+
....
Based on https://github.com/cirosantilli/x86-bare-metal-examples/tree/<commit-id> under CC BY-SA v4
....

If you want to use this work under a different license, contact the copyright owner, and he might make a good price.
