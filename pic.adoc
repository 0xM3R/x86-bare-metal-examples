== PIC

TODO examples.

Programmable interrupt controller:

* http://wiki.osdev.org/PIC
* http://www.jamesmolloy.co.uk/tutorial_html/5.-IRQs%20and%20the%20PIT.html

How it works:

....
Hardware -> IRQ -> PIC -> Interrupt handler
....

Each hardware has an IRQ, e.g. 0 for the PIT.

When an IRQ activated (e.g. PIT sends a signal), the PIC decides:

* whether or not it will call an interrupt handler. For example, without and EOI, further interrupts will not be generated.
* which interrupt handler it will call. This can be modified by programming the PIT.x
+
For example, Molloy shifts protected mode IRQs from interrupt 0 to 32, so that they won't conflict with the CPU defined exceptions in that area. https://github.com/cirosantilli/jamesmolloy-kernel-development-tutorials/blob/d15a2dfb721008e2a3df132c8cda37c0e62ad826/5_irq/descriptor_tables.c#L72

The default IRQ assignment is shown at: https://en.wikipedia.org/wiki/Interrupt_request_%28PC_architecture%29#x86_IRQs

Like other external circuits, the PIC is itself also programmed by `in` and `out` instructions.

=== EOI

End of interrupt.

We must tell the PIC that we are at the end.

Otherwise new interrupts with equal or lower precedence don't fire again.

https://en.wikipedia.org/wiki/End_of_interrupt

=== APIC

APIC vs PIC:

* allows for multithreading
* 24 IRQs instead of 15. The new top 8 are for PCI and deal better with conflicts.
* has a millisecond timer built-in. Different from the HPET.

=== Maskable interrupts

http://wiki.osdev.org/Non_Maskable_Interrupt

Interrupts generated by the CPU from 0 - 31 are not maskable: they generate interrupts even with `cli`.

Those from the PIC are maskable however.
